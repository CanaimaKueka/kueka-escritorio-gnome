#!/bin/bash -e
#
# ==============================================================================
# PAQUETE: canaima-escritorio-gnome
# ARCHIVO: postinst
# DESCRIPCIÓN: Configura el sistema despues la instalación del paquete.
# COPYRIGHT:
#  (C) 2010 Luis Alejandro Martínez Faneyth <martinez.faneyth@gmail.com>
#  (C) 2010 Diego Alberto Aguilera Zambrano <daguilera85@gmail.com>
#  (C) 2010 Carlos Alejandro Guerrero Mora <guerrerocarlos@gmail.com>
#  (C) 2010 Francisco Javier Vásquez Guerrero <franjvasquezg@gmail.com>
# LICENCIA: GPL3
# ==============================================================================
#
# Este programa es software libre. Puede redistribuirlo y/o modificarlo bajo los
# términos de la Licencia Pública General de GNU (versión 3).

PKG="canaima-escritorio-gnome"
GCONF_LIST="%gconf-tree-es.xml %gconf-tree-es_AR.xml %gconf-tree-es_ES.xml %gconf-tree-es_VE.xml"
FSTAB="/etc/fstab"
# Color Verde
VERDE="\e[1;32m"
# Color Rojo
ROJO="\e[1;31m"
# Color Amarillo
AMARILLO="\e[1;33m"
# Negrita
BOLD="\e[1m"
# Caracter de fin de línea
FIN="\e[0m"

function ERROR() {
echo -e ${ROJO}${1}${FIN}
}

function ADVERTENCIA() {
echo -e ${AMARILLO}${1}${FIN}
}

function EXITO() {
echo -e ${VERDE}${1}${FIN}
}

if [ -n "$(which laptop-detect)" ]; then
	if laptop-detect >/dev/null; then
		LAPTOP=true
	fi
fi

case ${1} in

	configure)
		
	# seccion agregada para configurar el toque del raton tactil solo en portatiles
	# lun mar 28 01:50:47 VET 2011, huntingbears, joaquinm
	if [ ${LAPTOP} == true ]; then
		
		[ ! -e /etc/modprobe.d/options.conf ] && touch /etc/modprobe.d/options.conf
		echo "options psmouse proto=imps" >> /etc/modprobe.d/options.conf

	fi

	ADVERTENCIA "Corrigiendo bug del Network-Manager de Debian"
	sed -i 's/managed=.*/managed=true/g' /etc/NetworkManager/NetworkManager.conf

	# ¿No existe la carpeta escritorio?
	if [ ! -d /etc/skel/Escritorio ]; then
		[ -h /etc/skel/Escritorio ] && rm -rf /etc/skel/Escritorio
		[ -f /etc/skel/Escritorio ] && rm -rf /etc/skel/Escritorio
		mkdir /etc/skel/Escritorio
		ADVERTENCIA "Creando carpeta Escritorio en /etc/skel/"
	fi 
	# ¿Existe un enlace simbólico llamado Desktop?
	# ¿Y una carpeta llamada Escritorio?
	if [ -h /etc/skel/Desktop ] && [ -d /etc/skel/Escritorio ]; then
		# Borra el enlace simbólico
		rm -rf /etc/skel/Desktop
		ADVERTENCIA "Removiendo enlace de escritorio Desktop en /etc/skel/"
	fi
	# ¿Existe un enlace simbólico llamado Escritorio?
	# ¿Y una carpeta llamada Desktop?
	if [ -h /etc/skel/Escritorio ] && [ -d /etc/skel/Desktop ]; then
		# Borra el enlace simbólico
		rm -rf /etc/skel/Escritorio
		# y renombra la carpeta a Escritorio
		mv /etc/skel/Desktop /etc/skel/Escritorio
		ADVERTENCIA "Borrando enlace simbólico Escritorio y renombrando carpeta Desktop a Escritorio en /etc/skel/"
	fi
	# ¿Existen dos directorios con el mismo propósito?
        if [ -d /etc/skel/Escritorio ] && [ -d /etc/skel/Desktop ]; then
		# Mueve el contenido de Desktop a Escritorio
        if [ $( ls -lah /etc/skel/Desktop | wc -l ) -gt 3 ]; then
    		mv /etc/skel/Desktop/* /etc/skel/Escritorio/
        fi
		# Borra la carpeta Desktop
		rm -rf /etc/skel/Desktop
		ADVERTENCIA "Moviendo el contenido de la carpeta Desktop a Escritorio y borrando Desktop en /etc/skel/"
	fi

	if [ -e /etc/default/prelink ]; then
		ADVERTENCIA "Pre-enlazando librerías para mejorar la eficiencia de Canaima (prelink)"
		echo "Éste proceso tomará un poco de tiempo dependiendo de la cantidad de programas instalados ..."
		echo "Le recomendamos que se tome un buen café venezolano mientras espera."
		sed -i 's/PRELINKING=unknown/PRELINKING=yes/g' /etc/default/prelink
		sed -i 's/PRELINKING=no/PRELINKING=yes/g' /etc/default/prelink
		/etc/cron.daily/prelink
	fi

	touch /.readahead

	#----- Inicio del parche de Lennart Poettering ---------------------------------------------------------------#
	#=============================================================================================================#
	ADVERTENCIA "Parcheando el sistema con el script de Lennart Poettering"

	# Para cada usuario en /home/ ...
	for usuario in /home/*? ; do

		# Obtenemos sólo el nombre del usuario
		usuario_min=$(basename ${usuario})

		# Y en caso de que el usuario sea un usuario activo (existente en /etc/shadow) ...
		case $(grep "${usuario_min}:.*:.*:.*:.*:.*:::" /etc/shadow) in

			'')
			# No hace nada si no se encuentra en /etc/shadow
			;;

			*)

			# Especificamos cuál es el archivo .bashrc
			BASHRC_F="/home/${usuario_min}/.bashrc"

			# Si la línea "/dev/cgroup/cpu/user" no se encuentra en el archivo .bashrc,
			# quiere decir que el script no ha sido implementado en éste sistema
			if [ $( cat ${BASHRC_F} | grep "/dev/cgroup/cpu/user" | wc -l ) == "0" ]; then

				# Respaldamos el archivo .bashrc anterior en .bashrc.respaldo
				echo "Respaldando ${BASHRC_F} en ${BASHRC_F}.respaldo"
				[ ! -e ${BASHRC_F}.respaldo ] && cp ${BASHRC_F} ${BASHRC_F}.respaldo

				echo "Parcheando ${BASHRC_F}"

				# Éste bloque de código se agrega al archivo .bashrc y es parte de lo propuesto por 
				# Lennart Poettering.
				echo "if [ \"\$PS1\" ] ; then" >> ${BASHRC_F}
				echo "mkdir -p -m 0700 /dev/cgroup/cpu/user/\$\$ > /dev/null 2>&1" >> ${BASHRC_F}
				echo "echo \$\$ > /dev/cgroup/cpu/user/\$\$/tasks" >> ${BASHRC_F}
				echo "echo \"1\" > /dev/cgroup/cpu/user/\$\$/notify_on_release" >> ${BASHRC_F}
				echo "fi" >> ${BASHRC_F}

				chown ${usuario_min}:${usuario_min} ${BASHRC_F}

			else

				# Si la línea "/dev/cgroup/cpu/user" se encuentra presente en el archivo
				# .bashrc quiere decir que ya se aplicó el script. Se ignora.
				ERROR "Parece que ya aplicaste el patch a ${BASHRC_F} con anterioridad. Ignorando."

			fi

			;;
		esac
	done

	# Especificando donde está el archivo rc.local
	RCLOCAL_F="/etc/rc.local"

	# Si la línea "/dev/cgroup/cpu/release_agent" no se encuentra en el archivo rc.local,
	# quiere decir que el script no ha sido implementado en éste sistema
	if [ $( cat ${RCLOCAL_F} | grep "/dev/cgroup/cpu/release_agent" | wc -l ) == "0" ]; then

		# Determinemos cuál es el número de línea del último comando "exit 0" dentro del archivo rc.local
		INSERTAR=$( cat ${RCLOCAL_F} | grep -n "exit 0" | sort -nr | head -n 1 | awk -F: '{print $1}' )

		# Respaldamos el archivo rc.local en rc.local.respaldo
		echo "Respaldando ${RCLOCAL_F} en ${RCLOCAL_F}.respaldo"
		[ ! -e ${RCLOCAL_F}.respaldo ] && cp ${RCLOCAL_F} ${RCLOCAL_F}.respaldo

		echo "Parcheando ${RCLOCAL_F}"

		# Insertamos éste bloque de código justo antes del último "exit 0" en un archivo temporal rc.local.nuevo
		sed "${INSERTAR}imkdir -p /dev/cgroup/cpu\nmount -t cgroup cgroup /dev/cgroup/cpu -o cpu\nmkdir -p -m 0777 /dev/cgroup/cpu/user\necho \"/usr/local/sbin/cgroup_clean\" > /dev/cgroup/cpu/release_agent" /etc/rc.local >> "${RCLOCAL_F}.nuevo"

		# Movemos el archivo temporal a su ubicación permanente
		mv ${RCLOCAL_F}.nuevo ${RCLOCAL_F}

		echo "Otorgando permisos de ejecución a ${RCLOCAL_F}"
		chmod +x ${RCLOCAL_F}

	else

		# Si la línea "/dev/cgroup/cpu/release_agent" se encuentra presente en el archivo
		# rc.local quiere decir que ya se aplicó el script. Se ignora.
		ERROR "Parece que ya aplicaste el patch a ${RCLOCAL_F} con anterioridad. Ignorando."

	fi

	# Especificando donde está el archivo cgroup_clean
	CGROUP_F="/usr/local/sbin/cgroup_clean"

	echo "Creando ${CGROUP_F}"

	# Insertamos el siguiente bloque de código en cgroup_clean
	echo "#!/bin/sh" > ${CGROUP_F}
	echo "if [ \"\$*\" != \"/user\" ]; then" >> ${CGROUP_F}
	echo "rmdir /dev/cgroup/cpu/\$*" >> ${CGROUP_F}
	echo "fi" >> ${CGROUP_F}

	echo "Otorgando permisos de ejecución a ${CGROUP_F}"
	chmod +x ${CGROUP_F}

	#----- Fin del parche de Lennart Poettering ------------------------------------------------------------------#
	#=============================================================================================================#


cat <<EOF >/etc/xdg/user-dirs.defaults
# Default settings for user directories
#
# The values are relative pathnames from the home directory and
# will be translated on a per-path-element basis into the users locale
DESKTOP=Escritorio
DOWNLOAD=Descargas
TEMPLATES=Plantillas
PUBLICSHARE=Público
DOCUMENTS=Documentos
MUSIC=Música
PICTURES=Imágenes
VIDEOS=Videos
# Another alternative is:
#MUSIC=Documents/Music
#PICTURES=Documents/Pictures
#VIDEOS=Documents/Videos

EOF

	ADVERTENCIA "Añadiendo noatime a /etc/fstab"

	if [ $( cat ${FSTAB} | grep -c "Optimizado para Canaima GNU/Linux" ) == 0 ]; then
		echo "#" >> ${FSTAB}
		echo "# Optimizado para Canaima GNU/Linux (agregado noatime a las opciones de disco)" >> ${FSTAB}
		echo "#" >> ${FSTAB}
	fi

	sed -i 's/   / /g' ${FSTAB}
	sed -i 's/   / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/, /,/g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/#.*//g' ${FSTAB}

	for datos in $( cat ${FSTAB} | awk '{print $3"##--TOKEN--##"$2"##--TOKEN--##"$4"##--TOKEN--##"$1}' ); do

		for fs in ext2 ext3 ext4 xfs ; do

		if [ $( echo $( expr "$datos" : "$fs" ) ) == 4 ]; then

		parsing=${datos#$fs##--TOKEN--##}
		dispositivo=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $1}' )
		dispositivo=$( echo $dispositivo | sed 's/\//\\\//g' )
		propiedad=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $2}' )
		uuid=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $3}' | sed 's/\//\\\//g' )

		case ${propiedad} in

			"defaults")

			if [ $dispositivo == "\/" ]; then
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			else
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime/g' ${FSTAB}
			fi

			;;

			"errors=remount-ro,defaults")
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			;;

			"defaults,errors=remount-ro")
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			;;

			"errors=remount-ro")

			if [ $dispositivo == "\/" ]; then
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			else
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' noatime,errors=remount-ro/g' ${FSTAB}
			fi

			;;

		esac

		fi

		done

	done

	if [ -d /var/lib/gconf/defaults/ ] && [ $(ls /var/lib/gconf/defaults/ | wc -l ) != 0 ]; then

	for gconf_limpiar in ${GCONF_LIST}; do
	[ -e /var/lib/gconf/defaults/${gconf_limpiar} ] && mv /var/lib/gconf/defaults/${gconf_limpiar} /tmp/
	done

	rm -rf /var/lib/gconf/defaults/*

	for gconf_limpiar in ${GCONF_LIST}; do
	[ -e /tmp/${gconf_limpiar} ] && mv /tmp/${gconf_limpiar} /var/lib/gconf/defaults/
	done

	fi

	if [ -d /usr/share/libgweather/ ] && [ $(ls /usr/share/libgweather/ | wc -l ) != 0 ]; then
	[ -e /usr/share/libgweather/Locations.es.xml.gz ] && mv /usr/share/libgweather/Locations.es.xml.gz /tmp/
	rm -rf /usr/share/libgweather/*
	[ -e /tmp/Locations.es.xml.gz ] && mv /tmp/Locations.es.xml.gz /usr/share/libgweather/
	fi

	# Para cada usuario en /home/ ...
	for usuario in /home/*? ; do

	# Obteniendo sólo el nombre del usuario
	usuario_min=$(basename ${usuario})

	# Y en caso de que el usuario sea un usuario activo (existente en /etc/shadow) ...
	case $( grep "${usuario_min}:.*:.*:.*:.*:.*:::" /etc/shadow ) in

	'')
	# No hace nada si no se encuentra en /etc/shadow
	;;

	*)

        # ¿No existe la carpeta Escritorio?
        if [ ! -d ${usuario}/Escritorio ]; then
		[ -h ${usuario}/Escritorio ] && rm -rf ${usuario}/Escritorio
		[ -f ${usuario}/Escritorio ] && rm -rf ${usuario}/Escritorio
                mkdir ${usuario}/Escritorio
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
                ADVERTENCIA "Creando carpeta Escritorio en ${usuario}"
        fi
	# ¿Existe un enlace simbólico llamado Desktop?
	# ¿Y una carpeta llamada Escritorio?
	if [ -h ${usuario}/Desktop ] && [ -d ${usuario}/Escritorio ]; then
		# Borra el enlace simbólico
		rm -f ${usuario}/Desktop
		ADVERTENCIA "Removiendo enlace de escritorio Desktop en ${usuario}"
	fi
	# ¿Existe un enlace simbólico llamado Escritorio?
	# ¿Y una carpeta llamada Desktop?
	if [ -h ${usuario}/Escritorio ] && [ -d ${usuario}/Desktop ]; then
		# Borra el enlace simbólico
		rm -f ${usuario}/Escritorio
		# y renombra la carpeta a Escritorio
		mv ${usuario}/Desktop ${usuario}/Escritorio
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
		ADVERTENCIA "Borrando enlace simbólico Escritorio y renombrando carpeta Desktop a Escritorio en ${usuario}"
	fi
	# ¿Existen dos directorios con el mismo propósito?
        if [ -d ${usuario}/Escritorio ] && [ -d ${usuario}/Desktop ]; then
		# Mueve el contenido de Desktop a Escritorio
        if [ $( ls -lah ${usuario}/Desktop | wc  -l ) -gt 3 ]; then
    		mv ${usuario}/Desktop/* ${usuario}/Escritorio/
        fi
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
		# Borra la carpeta Desktop
		rm -rf ${usuario}/Desktop
		ADVERTENCIA "Moviendo el contenido de la carpeta Desktop a Escritorio y borrando Desktop en ${usuario}"
	fi

	# Configuremos XDG para que use como locale "es_VE" y
	# Escritorio como carpeta de usuario predeterminada

	echo "es_VE" > ${usuario}/.config/user-dirs.locale

cat <<EOF >${usuario}/.config/user-dirs.dirs
# This file is written by xdg-user-dirs-update
# If you want to change or add directories, just edit the line you're
# interested in. All local changes will be retained on the next run
# Format is XDG_xxx_DIR="\$HOME/yyy", where yyy is a shell-escaped
# homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
# absolute path. No other format is supported.
#
XDG_DESKTOP_DIR="\$HOME/Escritorio"
XDG_DOWNLOAD_DIR="\$HOME/Descargas"
XDG_TEMPLATES_DIR="\$HOME/Plantillas"
XDG_PUBLICSHARE_DIR="\$HOME/Público"
XDG_DOCUMENTS_DIR="\$HOME/Documentos"
XDG_MUSIC_DIR="\$HOME/Música"
XDG_PICTURES_DIR="\$HOME/Imágenes"
XDG_VIDEOS_DIR="\$HOME/Videos"

EOF

	chown ${usuario_min}:${usuario_min} ${usuario}/.config/user-dirs.dirs
	chown ${usuario_min}:${usuario_min} ${usuario}/.config/user-dirs.locale

	# Actualicemos la configuración
	if [ -x $( which xdg-user-dirs-update ) ]; then
		su ${usuario_min} --command "xdg-user-dirs-update"
		su ${usuario_min} --command "xdg-user-dirs-update --force"
		EXITO "Carpetas de usuario actualizadas para '"${usuario_min}"'"
	fi
	
	;;

	esac
	done

	;;

	abort-upgrade|abort-remove|abort-deconfigure)
	;;

	*)

		ERROR "postinst no reconoce el argumento '"${1}"'" >&2
		exit 1

	;;

esac

#DEBHELPER#

exit 0
