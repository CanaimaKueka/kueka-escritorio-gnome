#!/bin/bash -e
#
# ==============================================================================
# PAQUETE: canaima-escritorio-gnome
# ARCHIVO: postinst
# DESCRIPCIÓN: Configura el sistema despues la instalación del paquete.
# COPYRIGHT:
#  (C) 2010 Luis Alejandro Martínez Faneyth <martinez.faneyth@gmail.com>
#  (C) 2010 Diego Alberto Aguilera Zambrano <daguilera85@gmail.com>
#  (C) 2010 Carlos Alejandro Guerrero Mora <guerrerocarlos@gmail.com>
#  (C) 2010 Francisco Javier Vásquez Guerrero <franjvasquezg@gmail.com>
# LICENCIA: GPL3
# ==============================================================================
#
# Este programa es software libre. Puede redistribuirlo y/o modificarlo bajo los
# términos de la Licencia Pública General de GNU (versión 3).

PKG="canaima-escritorio-gnome"
LIST="apmd anacron avahi-daemon bluetooth bluez-utils fetchmail dns-clean atd portmap rsync exim4 kerneloops acpi-fakekey acpi-support canaima-bienvenido-video cryptdisks cryptdisks-early dhcdbd fam hibernate hotkey-setup kbd keymap.sh live-initramfs ntp openvpn pcmciautils pppd-dns resolvconf samba screen-cleanup splashy tpconfig xdebconfigurator nfs-common statd"
FSTAB="/etc/fstab"
# Color Verde
VERDE="\e[1;32m"
# Color Rojo
ROJO="\e[1;31m"
# Color Amarillo
AMARILLO="\e[1;33m"
# Negrita
BOLD="\e[1m"
# Caracter de fin de línea
FIN="\e[0m"

function ERROR() {
echo -e ${ROJO}${1}${FIN}
}

function ADVERTENCIA() {
echo -e ${AMARILLO}${1}${FIN}
}

function EXITO() {
echo -e ${VERDE}${1}${FIN}
}

if [ -n "$(which laptop-detect)" ]; then
	if laptop-detect >/dev/null; then
		LAPTOP=true
	fi
fi

case ${1} in

	configure)

	ADVERTENCIA "Corrigiendo bug del Network-Manager de Debian"
	sed -i 's/managed=.*/managed=true/g' /etc/NetworkManager/NetworkManager.conf

	# ¿No existe la carpeta escritorio?
	if [ ! -d /etc/skel/Escritorio ]; then
		[ -h /etc/skel/Escritorio ] && rm -rf /etc/skel/Escritorio
		[ -f /etc/skel/Escritorio ] && rm -rf /etc/skel/Escritorio
		mkdir /etc/skel/Escritorio
		ADVERTENCIA "Creando carpeta Escritorio en /etc/skel/"
	fi 
	# ¿Existe un enlace simbólico llamado Desktop?
	# ¿Y una carpeta llamada Escritorio?
	if [ -h /etc/skel/Desktop ] && [ -d /etc/skel/Escritorio ]; then
		# Borra el enlace simbólico
		rm -rf /etc/skel/Desktop
		ADVERTENCIA "Removiendo enlace de escritorio Desktop en /etc/skel/"
	fi
	# ¿Existe un enlace simbólico llamado Escritorio?
	# ¿Y una carpeta llamada Desktop?
	if [ -h /etc/skel/Escritorio ] && [ -d /etc/skel/Desktop ]; then
		# Borra el enlace simbólico
		rm -rf /etc/skel/Escritorio
		# y renombra la carpeta a Escritorio
		mv /etc/skel/Desktop /etc/skel/Escritorio
		ADVERTENCIA "Borrando enlace simbólico Escritorio y renombrando carpeta Desktop a Escritorio en /etc/skel/"
	fi
	# ¿Existen dos directorios con el mismo propósito?
        if [ -d /etc/skel/Escritorio ] && [ -d /etc/skel/Desktop ]; then
		# Mueve el contenido de Desktop a Escritorio
		mv /etc/skel/Desktop/* /etc/skel/Escritorio/
		# Borra la carpeta Desktop
		rm -rf /etc/skel/Desktop
		ADVERTENCIA "Moviendo el contenido de la carpeta Desktop a Escritorio y borrando Desktop en /etc/skel/"
	fi

	# Para cada usuario en /home/ ...
	for usuario in /home/*? ; do

	# Obteniendo sólo el nombre del usuario
	usuario_min=$(basename ${usuario})

	# Y en caso de que el usuario sea un usuario activo (existente en /etc/shadow) ...
	case $( grep "${usuario_min}:.*:.*:.*:.*:.*:::" /etc/shadow ) in

	'')
	# No hace nada si no se encuentra en /etc/shadow
	;;

	*)

        # ¿No existe la carpeta Escritorio?
        if [ ! -d ${usuario}/Escritorio ]; then
		[ -h ${usuario}/Escritorio ] && rm -rf ${usuario}/Escritorio
		[ -f ${usuario}/Escritorio ] && rm -rf ${usuario}/Escritorio
                mkdir ${usuario}/Escritorio
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
                ADVERTENCIA "Creando carpeta Escritorio en ${usuario}"
        fi
	# ¿Existe un enlace simbólico llamado Desktop?
	# ¿Y una carpeta llamada Escritorio?
	if [ -h ${usuario}/Desktop ] && [ -d ${usuario}/Escritorio ]; then
		# Borra el enlace simbólico
		rm -f ${usuario}/Desktop
		ADVERTENCIA "Removiendo enlace de escritorio Desktop en ${usuario}"
	fi
	# ¿Existe un enlace simbólico llamado Escritorio?
	# ¿Y una carpeta llamada Desktop?
	if [ -h ${usuario}/Escritorio ] && [ -d ${usuario}/Desktop ]; then
		# Borra el enlace simbólico
		rm -f ${usuario}/Escritorio
		# y renombra la carpeta a Escritorio
		mv ${usuario}/Desktop ${usuario}/Escritorio
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
		ADVERTENCIA "Borrando enlace simbólico Escritorio y renombrando carpeta Desktop a Escritorio en ${usuario}"
	fi
	# ¿Existen dos directorios con el mismo propósito?
        if [ -d ${usuario}/Escritorio ] && [ -d ${usuario}/Desktop ]; then
		# Mueve el contenido de Desktop a Escritorio
		mv ${usuario}/Desktop/* ${usuario}/Escritorio/
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
		# Borra la carpeta Desktop
		rm -rf ${usuario}/Desktop
		ADVERTENCIA "Moviendo el contenido de la carpeta Desktop a Escritorio y borrando Desktop en ${usuario}"
	fi

	# Configuremos XDG para que use como locale "es_VE" y
	# Escritorio como carpeta de usuario predeterminada

	echo "es_VE" > ${usuario}/.config/user-dirs.locale

cat <<EOF >${usuario}/.config/user-dirs.dirs
# This file is written by xdg-user-dirs-update
# If you want to change or add directories, just edit the line you're
# interested in. All local changes will be retained on the next run
# Format is XDG_xxx_DIR="\$HOME/yyy", where yyy is a shell-escaped
# homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
# absolute path. No other format is supported.
#
XDG_DESKTOP_DIR="\$HOME/Escritorio"
XDG_DOWNLOAD_DIR="\$HOME/Descargas"
XDG_TEMPLATES_DIR="\$HOME/Plantillas"
XDG_PUBLICSHARE_DIR="\$HOME/Público"
XDG_DOCUMENTS_DIR="\$HOME/Documentos"
XDG_MUSIC_DIR="\$HOME/Música"
XDG_PICTURES_DIR="\$HOME/Imágenes"
XDG_VIDEOS_DIR="\$HOME/Videos"

EOF

	chown ${usuario_min}:${usuario_min} ${usuario}/.config/user-dirs.dirs
	chown ${usuario_min}:${usuario_min} ${usuario}/.config/user-dirs.locale
	;;

	esac
	done

cat <<EOF >/etc/xdg/user-dirs.defaults
# Default settings for user directories
#
# The values are relative pathnames from the home directory and
# will be translated on a per-path-element basis into the users locale
DESKTOP=Escritorio
DOWNLOAD=Descargas
TEMPLATES=Templates
PUBLICSHARE=Público
DOCUMENTS=Documentos
MUSIC=Música
PICTURES=Imágenes
VIDEOS=Videos
# Another alternative is:
#MUSIC=Documents/Music
#PICTURES=Documents/Pictures
#VIDEOS=Documents/Videos

EOF

	# Actualicemos la configuración
	if [ -x $( which xdg-user-dirs-update ) ]; then
		xdg-user-dirs-update
		EXITO "Carpetas de usuario actualizadas"
	fi

	#----- Inicio del parche de Lennart Poettering ---------------------------------------------------------------#
	#=============================================================================================================#
	ADVERTENCIA "Parcheando el sistema con el script de Lennart Poettering"

	# Para cada usuario en /home/ ...
	for usuario in /home/*? ; do

		# Obtenemos sólo el nombre del usuario
		usuario_min=$(basename ${usuario})

		# Y en caso de que el usuario sea un usuario activo (existente en /etc/shadow) ...
		case $(grep "${usuario_min}:.*:.*:.*:.*:.*:::" /etc/shadow) in

			'')
			# No hace nada si no se encuentra en /etc/shadow
			;;

			*)

			# Especificamos cuál es el archivo .bashrc
			BASHRC_F="/home/${usuario_min}/.bashrc"

			# Si la línea "/dev/cgroup/cpu/user" no se encuentra en el archivo .bashrc,
			# quiere decir que el script no ha sido implementado en éste sistema
			if [ $( cat ${BASHRC_F} | grep "/dev/cgroup/cpu/user" | wc -l ) == "0" ]; then

				# Respaldamos el archivo .bashrc anterior en .bashrc.respaldo
				echo "Respaldando ${BASHRC_F} en ${BASHRC_F}.respaldo"
				[ ! -e ${BASHRC_F}.respaldo ] && cp ${BASHRC_F} ${BASHRC_F}.respaldo

				echo "Parcheando ${BASHRC_F}"

				# Éste bloque de código se agrega al archivo .bashrc y es parte de lo propuesto por 
				# Lennart Poettering.
				echo "if [ \"\$PS1\" ] ; then" >> ${BASHRC_F}
				echo "mkdir -p -m 0700 /dev/cgroup/cpu/user/\$\$ > /dev/null 2>&1" >> ${BASHRC_F}
				echo "echo \$\$ > /dev/cgroup/cpu/user/\$\$/tasks" >> ${BASHRC_F}
				echo "echo \"1\" > /dev/cgroup/cpu/user/\$\$/notify_on_release" >> ${BASHRC_F}
				echo "fi" >> ${BASHRC_F}

				chown ${usuario_min}:${usuario_min} ${BASHRC_F}

			else

				# Si la línea "/dev/cgroup/cpu/user" se encuentra presente en el archivo
				# .bashrc quiere decir que ya se aplicó el script. Se ignora.
				ERROR "Parece que ya aplicaste el patch a ${BASHRC_F} con anterioridad. Ignorando."

			fi

			;;
		esac
	done

	# Especificando donde está el archivo rc.local
	RCLOCAL_F="/etc/rc.local"

	# Si la línea "/dev/cgroup/cpu/release_agent" no se encuentra en el archivo rc.local,
	# quiere decir que el script no ha sido implementado en éste sistema
	if [ $( cat ${RCLOCAL_F} | grep "/dev/cgroup/cpu/release_agent" | wc -l ) == "0" ]; then

		# Determinemos cuál es el número de línea del último comando "exit 0" dentro del archivo rc.local
		INSERTAR=$( cat ${RCLOCAL_F} | grep -n "exit 0" | sort -nr | head -n 1 | awk -F: '{print $1}' )

		# Respaldamos el archivo rc.local en rc.local.respaldo
		echo "Respaldando ${RCLOCAL_F} en ${RCLOCAL_F}.respaldo"
		[ ! -e ${RCLOCAL_F}.respaldo ] && cp ${RCLOCAL_F} ${RCLOCAL_F}.respaldo

echo "Parcheando ${RCLOCAL_F}"

		# Insertamos éste bloque de código justo antes del último "exit 0" en un archivo temporal rc.local.nuevo
		sed "${INSERTAR}imkdir -p /dev/cgroup/cpu\nmount -t cgroup cgroup /dev/cgroup/cpu -o cpu\nmkdir -m 0777 /dev/cgroup/cpu/user\necho \"/usr/local/sbin/cgroup_clean\" > /dev/cgroup/cpu/release_agent" /etc/rc.local >> "${RCLOCAL_F}.nuevo"

		# Movemos el archivo temporal a su ubicación permanente
		mv ${RCLOCAL_F}.nuevo ${RCLOCAL_F}

		echo "Otorgando permisos de ejecución a ${RCLOCAL_F}"
		chmod +x ${RCLOCAL_F}

	else

		# Si la línea "/dev/cgroup/cpu/release_agent" se encuentra presente en el archivo
		# rc.local quiere decir que ya se aplicó el script. Se ignora.
		ERROR "Parece que ya aplicaste el patch a ${RCLOCAL_F} con anterioridad. Ignorando."

	fi

	# Especificando donde está el archivo cgroup_clean
	CGROUP_F="/usr/local/sbin/cgroup_clean"

	echo "Creando ${CGROUP_F}"

	# Insertamos el siguiente bloque de código en cgroup_clean
	echo "#!/bin/sh" > ${CGROUP_F}
	echo "if [ \"\$*\" != \"/user\" ]; then" >> ${CGROUP_F}
	echo "rmdir /dev/cgroup/cpu/\$*" >> ${CGROUP_F}
	echo "fi" >> ${CGROUP_F}

	echo "Otorgando permisos de ejecución a ${CGROUP_F}"
	chmod +x ${CGROUP_F}

	#----- Fin del parche de Lennart Poettering ------------------------------------------------------------------#
	#=============================================================================================================#

	ADVERTENCIA "Removiendo scripts de inicio usualmente innecesarios"

	for list in ${LIST}; do
		if [ -n ${LAPTOP} ]; then
			if [ ${list} != "bluetooth" ] || [ ${list} != "bluez-utils" ] || [ ${list} != "hibernate" ] || [ ${list} != "pcmciautils" ]; then
				update-rc.d -f ${list} remove
				rm -rf /etc/init.d/${list}
			fi
		else
			update-rc.d -f ${list} remove
			rm -rf /etc/init.d/${list}
		fi
	done

	if [ -e /etc/default/avahi-daemon ]; then
		ADVERTENCIA "Asegurando que avahi-daemon no inicie"
		sed -i 's/AVAHI_DAEMON_DETECT_LOCAL=1/AVAHI_DAEMON_DETECT_LOCAL=0/g' /etc/default/avahi-daemon
	fi

	if [ -e /etc/default/rcS ]; then
		ADVERTENCIA "Cambiando la forma de carga de las dependencias iniciales del sistema (CONCURRENCY=makefile)"
		[ -z $( grep "CONCURRENCY=makefile" /etc/default/rcS ) ] && echo 'CONCURRENCY=makefile' >> /etc/default/rcS
	fi

	if [ -e /etc/sysctl.conf ]; then
		ADVERTENCIA "Reduciendo la cantidad de procesos que se swapean, la RAM es más rápida (vm.swappiness)"
		[ -z $( grep "vm.swappiness=10" /etc/sysctl.conf ) ] && echo 'vm.swappiness=10' >> /etc/sysctl.conf
	fi

	if [ -e /etc/default/prelink ]; then
		ADVERTENCIA "Pre-enlazando librerías para mejorar la eficiencia de Canaima (prelink)"
		echo "Éste proceso tomará un poco de tiempo dependiendo de la cantidad de programas instalados ..."
		echo "Le recomendamos que se tome un buen café venezolano mientras espera."
		sed -i 's/PRELINKING=unknown/PRELINKING=yes/g' /etc/default/prelink
		sed -i 's/PRELINKING=no/PRELINKING=yes/g' /etc/default/prelink
		/etc/cron.daily/prelink
	fi

	if [ -e /etc/inittab ];	then
		ADVERTENCIA "Reduciendo cantidad de TTY'S a 2, el usuario no las usa todas en realidad"
		sed -i 's/3:23:respawn:\/sbin\/getty/#3:23:respawn:\/sbin\/getty/g' /etc/inittab
		sed -i 's/4:23:respawn:\/sbin\/getty/#4:23:respawn:\/sbin\/getty/g' /etc/inittab
		sed -i 's/5:23:respawn:\/sbin\/getty/#5:23:respawn:\/sbin\/getty/g' /etc/inittab
		sed -i 's/6:23:respawn:\/sbin\/getty/#6:23:respawn:\/sbin\/getty/g' /etc/inittab
	fi

	DESHABILITAR_FSTAB=1

	if [ ${DESHABILITAR_FSTAB} == 0 ]; then

	ADVERTENCIA "Añadiendo noatime a /etc/fstab"

	if [ $( cat ${FSTAB} | grep "Optimizado para Canaima GNU/Linux" | wc -l ) == 0 ]; then
		echo "#" >> ${FSTAB}
		echo "# Optimizado para Canaima GNU/Linux (agregado noatime a las opciones de disco)" >> ${FSTAB}
		echo "#" >> ${FSTAB}
	fi

	sed -i 's/   / /g' ${FSTAB}
	sed -i 's/   / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/, /,/g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}

	for datos in $( cat ${FSTAB} | awk '{print $3"##--TOKEN--##"$2"##--TOKEN--##"$4"##--TOKEN--##"$1}' ); do

		for fs in ext2 ext3 ext4 xfs ; do

		if [ $( echo $( expr "$datos" : "$fs" ) ) == 4 ]; then

		parsing=${datos#$fs##--TOKEN--##}
		dispositivo=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $1}' )
		dispositivo=$( echo $dispositivo | sed 's/\//\\\//g' )
		propiedad=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $2}' )
		uuid=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $3}' )

		case ${propiedad} in

			"defaults")

			if [ $dispositivo == "\/" ]; then
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			else
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime/g' ${FSTAB}
			fi

			;;

			"errors=remount-ro,defaults")
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			;;

			"defaults,errors=remount-ro")
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			;;

			"errors=remount-ro")

			if [ $dispositivo == "\/" ]; then
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			else
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' noatime,errors=remount-ro/g' ${FSTAB}
			fi

			;;

		esac

		fi

		done

	done

	fi

	;;

	abort-upgrade|abort-remove|abort-deconfigure)
	;;

	*)

		ERROR "postinst no reconoce el argumento '"${1}"'" >&2
		exit 1

	;;

esac

#DEBHELPER#

exit 0
