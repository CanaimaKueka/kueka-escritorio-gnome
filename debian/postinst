#!/bin/bash -e
#
# ==============================================================================
# PAQUETE: canaima-escritorio-gnome
# ARCHIVO: postinst
# DESCRIPCIÓN: Configura el sistema despues la instalación del paquete.
# COPYRIGHT:
#  (C) 2010 Luis Alejandro Martínez Faneyth <martinez.faneyth@gmail.com>
#  (C) 2010 Diego Alberto Aguilera Zambrano <daguilera85@gmail.com>
#  (C) 2010 Carlos Alejandro Guerrero Mora <guerrerocarlos@gmail.com>
#  (C) 2010 Francisco Javier Vásquez Guerrero <franjvasquezg@gmail.com>
# LICENCIA: GPL3
# ==============================================================================
#
# Este programa es software libre. Puede redistribuirlo y/o modificarlo bajo los
# términos de la Licencia Pública General de GNU (versión 3).

PKG="canaima-escritorio-gnome"
# Procedimiento para remover traducciones del gconf - REQUIERE INVESTIGACIÓN
#GCONF_LIST="%gconf-tree-es.xml %gconf-tree-es_AR.xml %gconf-tree-es_ES.xml %gconf-tree-es_VE.xml"
FSTAB="/etc/fstab"
# Color Verde
VERDE="\e[1;32m"
# Color Rojo
ROJO="\e[1;31m"
# Color Amarillo
AMARILLO="\e[1;33m"
# Negrita
BOLD="\e[1m"
# Caracter de fin de línea
FIN="\e[0m"

function ERROR() {
echo -e ${ROJO}${1}${FIN}
}

function ADVERTENCIA() {
echo -e ${AMARILLO}${1}${FIN}
}

function EXITO() {
echo -e ${VERDE}${1}${FIN}
}

if [ -n "$(which laptop-detect)" ]; then
	if laptop-detect >/dev/null; then
		LAPTOP=true
	fi
fi

case ${1} in

	configure)
		
	# seccion agregada para configurar el toque del raton tactil solo en portatiles
	# lun mar 28 01:50:47 VET 2011, huntingbears, joaquinm
	if [ "${LAPTOP}" == "true" ]; then
		
		[ ! -e /etc/modprobe.d/options.conf ] && touch /etc/modprobe.d/options.conf
		echo "options psmouse proto=imps" >> /etc/modprobe.d/options.conf

	fi

	ADVERTENCIA "Corrigiendo bug del Network-Manager de Debian"
	sed -i 's/managed=.*/managed=true/g' /etc/NetworkManager/NetworkManager.conf

	# ¿No existe la carpeta escritorio?
	if [ ! -d /etc/skel/Escritorio ]; then
		[ -h /etc/skel/Escritorio ] && rm -rf /etc/skel/Escritorio
		[ -f /etc/skel/Escritorio ] && rm -rf /etc/skel/Escritorio
		mkdir /etc/skel/Escritorio
		ADVERTENCIA "Creando carpeta Escritorio en /etc/skel/"
	fi 
	# ¿Existe un enlace simbólico llamado Desktop?
	# ¿Y una carpeta llamada Escritorio?
	if [ -h /etc/skel/Desktop ] && [ -d /etc/skel/Escritorio ]; then
		# Borra el enlace simbólico
		rm -rf /etc/skel/Desktop
		ADVERTENCIA "Removiendo enlace de escritorio Desktop en /etc/skel/"
	fi
	# ¿Existe un enlace simbólico llamado Escritorio?
	# ¿Y una carpeta llamada Desktop?
	if [ -h /etc/skel/Escritorio ] && [ -d /etc/skel/Desktop ]; then
		# Borra el enlace simbólico
		rm -rf /etc/skel/Escritorio
		# y renombra la carpeta a Escritorio
		mv /etc/skel/Desktop /etc/skel/Escritorio
		ADVERTENCIA "Borrando enlace simbólico Escritorio y renombrando carpeta Desktop a Escritorio en /etc/skel/"
	fi
	# ¿Existen dos directorios con el mismo propósito?
        if [ -d /etc/skel/Escritorio ] && [ -d /etc/skel/Desktop ]; then
		# Mueve el contenido de Desktop a Escritorio
        if [ $( ls -lah /etc/skel/Desktop | wc -l ) -gt 3 ]; then
    		mv /etc/skel/Desktop/* /etc/skel/Escritorio/
        fi
		# Borra la carpeta Desktop
		rm -rf /etc/skel/Desktop
		ADVERTENCIA "Moviendo el contenido de la carpeta Desktop a Escritorio y borrando Desktop en /etc/skel/"
	fi

	if [ -e /etc/default/prelink ]; then
		ADVERTENCIA "Pre-enlazando librerías para mejorar la eficiencia de Canaima (prelink)"
		echo "Éste proceso tomará un poco de tiempo dependiendo de la cantidad de programas instalados ..."
		echo "Le recomendamos que se tome un buen café venezolano mientras espera."
		sed -i 's/PRELINKING=.*/PRELINKING=yes/g' /etc/default/prelink
		/etc/cron.daily/prelink
	fi

	touch /.readahead_collector

	#----- Inicio del parche de Lennart Poettering ---------------------------------------------------------------#
	#=============================================================================================================#

	# Verificamos que tenemos soporte para cgroups
	if [ ! -z "$( cat /proc/filesystems | grep cgroup )" ]; then

	# Montamos el fs cgroup y lo adjuntamos a /etc/fstab
#	if [ -x $( which mount ) ]; then
#		mount -t tmpfs tmpfs /sys/fs/cgroup
#	fi

	if [ -z "$( grep "tmpfs /sys/fs/cgroup tmpfs defaults 0 0" /etc/fstab )" ]; then
		# si no hemos montado los cgroups
		echo "tmpfs /sys/fs/cgroup tmpfs defaults 0 0" >> /etc/fstab
	fi

	# Aplicamos la gestion de grupos por usuario a cada usuario activo del sistema
	for usuario in $( grep "/home/" /etc/passwd | awk -F: '{print $1}' ) ; do

		userid=$( grep ${usuario} /etc/passwd | awk -F: '{print $3}' | bc -l )
		# Verificamos si es un usuario valido para iniciar sesion
		if [ ${userid} -gt 999 ]; then

			# Especificamos cuál es el archivo .bashrc
			BASHRC_U="/home/${usuario}/.bashrc"

			if [ -f $BASHRC_U ]; then
			# de existir el archivo bashrc
				# Si la línea "/sys/fs/cgroup/cpu/user" no se encuentra en el archivo .bashrc,
				# quiere decir que el script no ha sido implementado en éste sistema
				if [ $( cat ${BASHRC_U} | grep "/sys/fs/cgroup/cpu/user" | wc -l ) == "0" ]; then
					# Respaldamos el archivo .bashrc anterior en .bashrc.respaldo
					echo "Respaldando ${BASHRC_U} en ${BASHRC_U}.respaldo"
					[ ! -e ${BASHRC_U}.respaldo ] && cp ${BASHRC_U} ${BASHRC_U}.respaldo

					echo "Iniciando aplicacion parche de Lennart Poettering ${BASHRC_U}"

					# Éste bloque de código se agrega al archivo .bashrc y es parte de lo propuesto por 
					# Lennart Poettering.
					echo "if [ \"\$PS1\" ] ; then" >> ${BASHRC_U}
					echo "mkdir -p -m 0700 /sys/fs/cgroup/cpu/user/\$\$ > /dev/null 2>&1" >> ${BASHRC_U}
					echo "echo \$\$ > /sys/fs/cgroup/cpu/user/\$\$/tasks" >> ${BASHRC_U}
					echo "echo \"1\" > /sys/fs/cgroup/cpu/user/\$\$/notify_on_release" >> ${BASHRC_U}
					echo "fi" >> ${BASHRC_U}
					# el usuario debe ser propietario de su bashrc
					chown ${usuario}:${usuario} ${BASHRC_U}
				else
					# Si la línea "/sys/fs/cgroup/cpu/user" se encuentra presente en el archivo
					# .bashrc quiere decir que ya se aplicó el script. Se ignora.
					ERROR "Parece que ya aplicaste el patch a ${BASHRC_U} con anterioridad. Ignorando."
				fi		
			fi
		fi	
	done

	# Especificando donde está el archivo rc.local
	RCLOCAL_F="/etc/rc.local"
	# TODO: buscar una ubicacion que sea ejecutable en init 3 o superior
		# Si la línea "/sys/fs/cgroup/cpu/release_agent" no se encuentra en el archivo rc.local,
		# quiere decir que el script no ha sido implementado en éste sistema
		if [ $( cat ${RCLOCAL_F} | grep -c "/sys/fs/cgroup/cpu/release_agent" ) == "0" ]; then
			# Determinemos cuál es el número de línea del último comando "exit 0" dentro del archivo rc.local
			INSERTAR=$( cat ${RCLOCAL_F} | grep -n "exit 0" | sort -nr | head -n 1 | awk -F: '{print $1}' )
		
			# Respaldamos el archivo rc.local en rc.local.respaldo
			echo "Respaldando ${RCLOCAL_F} en ${RCLOCAL_F}.respaldo"
			[ ! -e ${RCLOCAL_F}.respaldo ] && cp ${RCLOCAL_F} ${RCLOCAL_F}.respaldo

			echo "Aplicando parche ${RCLOCAL_F}"

			# Insertamos éste bloque de código justo antes del último "exit 0" en un archivo temporal rc.local.nuevo
			sed "${INSERTAR}imkdir -p /sys/fs/cgroup/cpu\nmount -t cgroup cgroup /sys/fs/cgroup/cpu -o cpu\nmkdir -p -m 0777 /sys/fs/cgroup/cpu/user\necho \"/usr/local/sbin/cgroup_clean\" > /sys/fs/cgroup/cpu/release_agent" /etc/rc.local >> "${RCLOCAL_F}.nuevo"
			# Movemos el archivo temporal a su ubicación permanente
			mv ${RCLOCAL_F}.nuevo ${RCLOCAL_F}

			echo "Otorgando permisos de ejecución a ${RCLOCAL_F}"
			chmod +x ${RCLOCAL_F}
		else
			# Si la línea "/sys/fs/cgroup/cpu/release_agent" se encuentra presente en el archivo
			# rc.local quiere decir que ya se aplicó el script. Se ignora.
			ERROR "Parece que ya aplicaste el patch a ${RCLOCAL_F} con anterioridad. Ignorando."
		fi

	# Especificando donde está el archivo cgroup_clean
	CGROUP_F="/usr/local/sbin/cgroup_clean"

	# Insertamos el siguiente bloque de código en cgroup_clean
cat <<EOF >> $CGROUP_F
#!/bin/sh
if [ "$*" != "/user" ]; then
rmdir /sys/fs/cgroup/cpu/$*
fi
EOF
		echo "Otorgando permisos de ejecución a ${CGROUP_F}"
		chmod +x ${CGROUP_F}

	else
		ERROR "Parece que tu sistema no soporta CGROUPS, obviando aplicación del parche."

	fi

	#----- Fin del parche de Lennart Poettering ------------------------------------------------------------------#
	#=============================================================================================================#


cat <<EOF >/etc/xdg/user-dirs.defaults
# Default settings for user directories
#
# The values are relative pathnames from the home directory and
# will be translated on a per-path-element basis into the users locale
DESKTOP=Escritorio
DOWNLOAD=Descargas
TEMPLATES=Plantillas
PUBLICSHARE=Público
DOCUMENTS=Documentos
MUSIC=Música
PICTURES=Imágenes
VIDEOS=Videos
# Another alternative is:
#MUSIC=Documents/Music
#PICTURES=Documents/Pictures
#VIDEOS=Documents/Videos

EOF

	ADVERTENCIA "Añadiendo noatime a /etc/fstab"

	if [ $( cat ${FSTAB} | grep -c "Optimizado para Canaima GNU/Linux" ) == 0 ]; then
		echo "#" >> ${FSTAB}
		echo "# Optimizado para Canaima GNU/Linux (agregado noatime a las opciones de disco)" >> ${FSTAB}
		echo "#" >> ${FSTAB}
	fi

	sed -i 's/   / /g' ${FSTAB}
	sed -i 's/   / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/, /,/g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/  / /g' ${FSTAB}
	sed -i 's/#.*//g' ${FSTAB}

	for datos in $( cat ${FSTAB} | awk '{print $3"##--TOKEN--##"$2"##--TOKEN--##"$4"##--TOKEN--##"$1}' ); do

		for fs in ext2 ext3 ext4 xfs ; do

		if [ $( echo $( expr "$datos" : "$fs" ) ) == 4 ]; then

		parsing=${datos#$fs##--TOKEN--##}
		dispositivo=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $1}' )
		dispositivo=$( echo $dispositivo | sed 's/\//\\\//g' )
		propiedad=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $2}' )
		uuid=$( echo $parsing | sed 's/##--TOKEN--##/ /g' | awk '{print $3}' | sed 's/\//\\\//g' )

		case ${propiedad} in

			"defaults")

			if [ $dispositivo == "\/" ]; then
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			else
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime/g' ${FSTAB}
			fi

			;;

			"errors=remount-ro,defaults")
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			;;

			"defaults,errors=remount-ro")
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			;;

			"errors=remount-ro")

			if [ $dispositivo == "\/" ]; then
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' defaults,noatime,errors=remount-ro/g' ${FSTAB}
			else
				sed -i 's/'${uuid}' '${dispositivo}' '${fs}' '${propiedad}'/'${uuid}' '${dispositivo}' '${fs}' noatime,errors=remount-ro/g' ${FSTAB}
			fi

			;;

		esac

		fi

		done

	done
	EXITO "modificar /etc/default/useradd,nuevos privilegios para nuevos usuarios"
	# Procedimiento para modificar /etc/default/useradd para la creacion de nuevos usurios con nuevos privilegios 
        # -----------------------------------------------------------------------------------------------------
	G_GRUPOS="lp netdev lpadmin powerdev"
	G_CONF="/etc/group"
	i=0
	for GRUPO in ${G_GRUPOS}
	do
		let i=$i+1
		GID${i}=$( cat ${G_CONF} | grep -w ${GRUPO} | sed 's/:/ /g' | awk '{print $3}')
		#echo ${GID}
	done 
	sed -i 's/# GROUP=.*/GROUP=100,${GID1},${GID2},${GID3},${GID4}/g' /etc/default/useradd

	# Procedimiento para editar los grupos de usuarios activos
        # -----------------------------------------------------------------------------------------------------
	EXITO "modificando privilegios a usurios actuales"
	for usuario in /home/*? ; do
        	usuario_c=$(basename ${usuario})
		usermod ${usuario_c} -a -G lp,lpadmin,netdev,powerdev
	done
		
	# -----------------------------------------------------------------------------------------------------

	# Procedimiento para remover traducciones del gconf - REQUIERE INVESTIGACIÓN
	# -----------------------------------------------------------------------------------------------------
	#if [ -d /var/lib/gconf/defaults/ ] && [ $(ls /var/lib/gconf/defaults/ | wc -l ) != 0 ]; then

	#for gconf_limpiar in ${GCONF_LIST}; do
	#[ -e /var/lib/gconf/defaults/${gconf_limpiar} ] && mv /var/lib/gconf/defaults/${gconf_limpiar} /tmp/
	#done

	#rm -rf /var/lib/gconf/defaults/*

	#for gconf_limpiar in ${GCONF_LIST}; do
	#[ -e /tmp/${gconf_limpiar} ] && mv /tmp/${gconf_limpiar} /var/lib/gconf/defaults/
	#done

	#fi

	# Procedimiento para remover locaciones de libgweather - REQUIERE INVESTIGACIÓN
	# -----------------------------------------------------------------------------------------------------
	#if [ -d /usr/share/libgweather/ ] && [ $(ls /usr/share/libgweather/ | wc -l ) != 0 ]; then
	#[ -e /usr/share/libgweather/Locations.es.xml.gz ] && mv /usr/share/libgweather/Locations.es.xml.gz /tmp/
	#rm -rf /usr/share/libgweather/*
	#[ -e /tmp/Locations.es.xml.gz ] && mv /tmp/Locations.es.xml.gz /usr/share/libgweather/
	#fi

	# Para cada usuario en /home/ ...
	for usuario in /home/*? ; do

	# Obteniendo sólo el nombre del usuario
	usuario_min=$(basename ${usuario})

	# Y en caso de que el usuario sea un usuario activo (existente en /etc/shadow) ...
	case $( grep "${usuario_min}:.*:.*:.*:.*:.*:::" /etc/shadow ) in

	'')
	# No hace nada si no se encuentra en /etc/shadow
	;;

	*)

        # ¿No existe la carpeta Escritorio?
        if [ ! -d ${usuario}/Escritorio ]; then
		[ -h ${usuario}/Escritorio ] && rm -rf ${usuario}/Escritorio
		[ -f ${usuario}/Escritorio ] && rm -rf ${usuario}/Escritorio
                mkdir ${usuario}/Escritorio
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
                ADVERTENCIA "Creando carpeta Escritorio en ${usuario}"
        fi
	# ¿Existe un enlace simbólico llamado Desktop?
	# ¿Y una carpeta llamada Escritorio?
	if [ -h ${usuario}/Desktop ] && [ -d ${usuario}/Escritorio ]; then
		# Borra el enlace simbólico
		rm -f ${usuario}/Desktop
		ADVERTENCIA "Removiendo enlace de escritorio Desktop en ${usuario}"
	fi
	# ¿Existe un enlace simbólico llamado Escritorio?
	# ¿Y una carpeta llamada Desktop?
	if [ -h ${usuario}/Escritorio ] && [ -d ${usuario}/Desktop ]; then
		# Borra el enlace simbólico
		rm -f ${usuario}/Escritorio
		# y renombra la carpeta a Escritorio
		mv ${usuario}/Desktop ${usuario}/Escritorio
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
		ADVERTENCIA "Borrando enlace simbólico Escritorio y renombrando carpeta Desktop a Escritorio en ${usuario}"
	fi
	# ¿Existen dos directorios con el mismo propósito?
        if [ -d ${usuario}/Escritorio ] && [ -d ${usuario}/Desktop ]; then
		# Mueve el contenido de Desktop a Escritorio
        if [ $( ls -lah ${usuario}/Desktop | wc  -l ) -gt 3 ]; then
    		mv ${usuario}/Desktop/* ${usuario}/Escritorio/
        fi
		chown -R ${usuario_min}:${usuario_min} ${usuario}/Escritorio
		# Borra la carpeta Desktop
		rm -rf ${usuario}/Desktop
		ADVERTENCIA "Moviendo el contenido de la carpeta Desktop a Escritorio y borrando Desktop en ${usuario}"
	fi

	# Configuremos XDG para que use como locale "es_VE" y
	# Escritorio como carpeta de usuario predeterminada

	echo "es_VE" > ${usuario}/.config/user-dirs.locale

cat <<EOF >${usuario}/.config/user-dirs.dirs
# This file is written by xdg-user-dirs-update
# If you want to change or add directories, just edit the line you're
# interested in. All local changes will be retained on the next run
# Format is XDG_xxx_DIR="\$HOME/yyy", where yyy is a shell-escaped
# homedir-relative path, or XDG_xxx_DIR="/yyy", where /yyy is an
# absolute path. No other format is supported.
#
XDG_DESKTOP_DIR="\$HOME/Escritorio"
XDG_DOWNLOAD_DIR="\$HOME/Descargas"
XDG_TEMPLATES_DIR="\$HOME/Plantillas"
XDG_PUBLICSHARE_DIR="\$HOME/Público"
XDG_DOCUMENTS_DIR="\$HOME/Documentos"
XDG_MUSIC_DIR="\$HOME/Música"
XDG_PICTURES_DIR="\$HOME/Imágenes"
XDG_VIDEOS_DIR="\$HOME/Videos"

EOF

	chown -R ${usuario_min}:${usuario_min} ${usuario}/.config

	# Actualicemos la configuración
	if [ -x $( which xdg-user-dirs-update ) ]; then
		su ${usuario_min} --command "xdg-user-dirs-update"
		su ${usuario_min} --command "xdg-user-dirs-update --force"
		EXITO "Carpetas de usuario actualizadas para '"${usuario_min}"'"
	fi
	
	;;

	esac
	done

	;;

	abort-upgrade|abort-remove|abort-deconfigure)
	;;

	*)

		ERROR "postinst no reconoce el argumento '"${1}"'" >&2
		exit 1

	;;

esac

#DEBHELPER#

exit 0
